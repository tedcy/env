snippet cpptest
#include <iostream>
#include <sstream>
#include <deque>
#include <chrono>
#include <pthread.h>
#include <thread>
#include <string>
#include <system_error>
#include <type_traits>
#include <vector>
#include <mutex>
#include <iconv.h>
#include <assert.h>
#include <algorithm>
#include <iomanip>
#include <map>
#include <set>

using namespace std;
using namespace std::chrono;

#define OUT(x) cout << #x << " = " << x << endl
#define O(x) cout << x << endl

struct Timer { Timer() : tp(system_clock::now()) {} virtual ~Timer() { auto dur = system_clock::now() - tp; O("Cost " << duration_cast<milliseconds>(dur).count() << " ms"); } system_clock::time_point tp; };
struct Bench : public Timer { Bench() : val(0) {} virtual ~Bench() { stop(); } void stop() { auto dur = system_clock::now() - tp; O("Per op: " << duration_cast<nanoseconds>(dur).count() / std::max(val, 1L) << " ns"); auto perf = (double)val / duration_cast<milliseconds>(dur).count() / 10; if (perf < 1) O("Performance: " << std::setprecision(3) << perf << " w/s"); else O("Performance: " << perf << " w/s"); } Bench& operator++() { ++val; return *this; } Bench& operator++(int) { ++val; return *this; } Bench& add(long v) { val += v; return *this; } long val; };

int main() {

}

endsnippet

snippet lc1
#define OUT(x) cout << #x << " = " << x << endl
#define O(x) cout << x << endl
#define LOGV(x) "|" << #x << "=" << x << "|"

template <typename IndexType, typename V>
struct A{
    using K = typename std::decay<decltype(declval<V>().*(declval<IndexType>()))>::type;
    using K1 = decltype(declval<V>().*(declval<IndexType>()));
};

struct Foo {
    string a;
};

template <typename T>
struct C{
    C() {
        B<T> b;
    };
    template <typename K, typename fake = void>
    struct B {
        B() {
            cout << "1" << endl;
        }
    };
    template <typename fake>
    struct B<int, fake> {
        B() {
            cout << "2" << endl;
        }
    };
};

endsnippet

snippet lc2
struct A1{};

template <typename T>
struct B{
    template <typename T1 = T>
    void set(T && t,
            typename std::enable_if<std::is_move_constructible<T1>::value>::type* = 0) {
    }
};
endsnippet
